public class Cube {

    // first 8 correspond to corners position (0 - 7)
    // next 12 correspond to edges position (0 - 11)
    // next 8 correspond to corners permutation (0 - 2)
    // next 12 correspond to edges permutation (0 - 1)
    private byte[] cube = new byte[40];
    private byte t;


    public Cube() {

        for (byte i = 0; i < 8; i++) {
            this.cube[i] = i;
            this.cube[i + 20] = 0;
        }

        for (byte i = 0; i < 12; i++) {
            this.cube[i + 8] = i;
            this.cube[i + 28] = 0;
        }
    }

    public byte[] getCorners() {
        byte[] corners = new byte[8];
        System.arraycopy(this.cube, 0, corners, 0, 8);
        return corners;
    }

    public byte[] getEdges() {
        byte[] edges = new byte[12];
        System.arraycopy(this.cube, 8, edges, 0, 12);
        return edges;
    }

    public void performMoves(String moves) {

        if (moves == null || moves.isEmpty()) {
            return;
        }

        String[] moveList = moves.split(" ");

        for (String move : moveList) {
            switch (move) {
                case "F" -> F();
                case "F'" -> Fp();
                case "F2" -> F2();
                case "B" -> B();
                case "B'" -> Bp();
                case "B2" -> B2();
                case "R" -> R();
                case "R'" -> Rp();
                case "R2" -> R2();
                case "L" -> L();
                case "L'" -> Lp();
                case "L2" -> L2();
                case "U" -> U();
                case "U'" -> Up();
                case "U2" -> U2();
                case "D" -> D();
                case "D'" -> Dp();
                case "D2" -> D2();
                default -> System.out.println("Invalid move: " + move);
            }
        }
    }

    public void applyMove(int move) {
        switch (move) {
            case 0 -> U();
            case 1 -> Up();
            case 2 -> D();
            case 3 -> Dp();
            case 4 -> L();
            case 5 -> Lp();
            case 6 -> R();
            case 7 -> Rp();
            case 8 -> F();
            case 9 -> Fp();
            case 10 -> B();
            case 11 -> Bp();
        }
    }

    public void undoMove(int move) {
        switch (move) {
            case 0 -> Up();
            case 1 -> U();
            case 2 -> Dp();
            case 3 -> D();
            case 4 -> Lp();
            case 5 -> L();
            case 6 -> Rp();
            case 7 -> R();
            case 8 -> Fp();
            case 9 -> F();
            case 10 -> Bp();
            case 11 -> B();
        }
    }

    public boolean isSolved() {
        for (byte i = 0; i < 8; i++) {
            if (this.cube[i] !=  i || this.cube[i + 20] != 0) {
                return false;
            }
        }
        for (byte i = 0; i < 12; i++) {
            if (this.cube[i + 8] !=  i || this.cube[i + 28] != 0) {
                return false;
            }
        }
        return true;
    }

    public byte getHeuristic() {
        return 0;
    }

    public byte[] getCube() {
        byte[] cube = new byte[54];

        for (int i = 0; i < 6; i++) {
            cube[9 * i + 4] =  (byte) i;
        }

        for (int i = 0; i < 8; i++) {

            byte cp = this.cube[i];
            byte co = this.cube[i + 20];
            byte[] index = indexCorners(cp);
            byte rot = co;

            cube[index[0]] = colorCorners(i, (byte) ((0 + rot) % 3));
            cube[index[1]] = colorCorners(i, (byte) ((1 + rot) % 3));
            cube[index[2]] = colorCorners(i, (byte) ((2 + rot) % 3));
        }

        for (int i = 0; i < 12; i++) {

            byte edge = this.cube[i + 8];
            byte eo = this.cube[i + 28];
            byte[] index = indexEdges(edge);
            byte rot = eo;

            cube[index[0]] = colorEdges(i, (byte) ((0 + rot) % 2));
            cube[index[1]] = colorEdges(i, (byte) ((1 + rot) % 2));
        }

        return cube;
    }

    private byte colorCorners(int n, byte c) {
        byte[] tileColors0 = {0, 0, 0, 0, 5, 5, 5, 5};
        byte[] tileColors1 = {1, 4, 3, 2, 4, 3, 2, 1};
        byte[] tileColors2 = {4, 3, 2, 1, 1, 4, 3, 2};

        switch (c) {
            case 0: return tileColors0[n];
            case 1: return tileColors1[n];
            case 2: return tileColors2[n];
            default: return -1;
        }
    }

    private byte colorEdges(int n, byte c) {
        byte[] tileColors0 = {0, 0, 0, 0, 4, 4, 2, 2, 5, 5, 5, 5};
        byte[] tileColors1 = {4, 3, 2, 1, 1, 3, 3, 1, 4, 3, 2, 1};

        return switch (c) {
            case 0 -> tileColors0[n];
            case 1 -> tileColors1[n];
            default ->  -1;
        };
    }

    private byte[] indexCorners(byte c) {
        byte[] index = new byte[3];

        switch (c) {
            // for top corners of cube
            case 0: return new byte[] {0, 9, 38};
            case 1: return new byte[] {2, 36, 29};
            case 2: return new byte[] {8, 27, 20};
            case 3: return new byte[] {6, 18, 11};
            // for bottom corners of cube
            case 4: return new byte[] {51, 44, 15};
            case 5: return new byte[] {53, 35, 42};
            case 6: return new byte[] {47, 26, 33};
            case 7: return new byte[] {45, 17, 24};
            default: return index;
        }
    }

    private byte[] indexEdges(byte e) {
        byte[] index = new byte[2];

        switch (e) {
            // top edges
            case 0: return new byte[] {1, 37};
            case 1:  return new byte[] {5, 28};
            case 2:  return new byte[] {7, 19};
            case 3: return new byte[] {3, 10};

            // middle layer edges
            case 4: return new byte[] {41, 12};
            case 5:  return new byte[] {39, 32};
            case 6:   return new byte[] {23, 30};
            case 7:  return new byte[] {21, 14};

            // bottom edges
            case 8: return new byte[] {52, 43};
            case 9:  return new byte[] {50, 34};
            case 10:  return new byte[] {46, 25};
            case 11: return new byte[] {48, 16};

            default: return index;
        }
    }

    public void U() {
        // rotate corner positions 0->1->2->3
        t = cube[0];
        cube[0] = cube[1];
        cube[1] = cube[2];
        cube[2] = cube[3];
        cube[3] = t;

        // rotate edge positions 0->1->2->3
        t = cube[8];
        cube[8] = cube[9];
        cube[9] = cube[10];
        cube[10] = cube[11];
        cube[11] = t;
    }

    public void Up() {
        // rotate corner positions 0<-1<-2<-3 (inverse of U)
        t = cube[3];
        cube[3] = cube[2];
        cube[2] = cube[1];
        cube[1] = cube[0];
        cube[0] = t;

        // rotate edge positions 8<-9<-10<-11 (inverse of U)
        t = cube[11];
        cube[11] = cube[10];
        cube[10] = cube[9];
        cube[9] = cube[8];
        cube[8] = t;
    }

    public void U2() {
        // rotate corner positions 0<->2 and 1<->3
        t = cube[0];
        cube[0] = cube[2];
        cube[2] = t;
        t = cube[1];
        cube[1] = cube[3];
        cube[3] = t;

        // rotate edge positions 8<->10 and 9<->11
        t = cube[8];
        cube[8] = cube[10];
        cube[10] = t;
        t = cube[9];
        cube[9] = cube[11];
        cube[11] = t;
    }

    public void D() {
        // inverse of D: rotate corner positions 4<-5<-6<-7
        t = cube[7];
        cube[7] = cube[6];
        cube[6] = cube[5];
        cube[5] = cube[4];
        cube[4] = t;

        // inverse of D for edges 16<-17<-18<-19
        t = cube[19];
        cube[19] = cube[18];
        cube[18] = cube[17];
        cube[17] = cube[16];
        cube[16] = t;
    }

    public void Dp() {
        // rotate corner positions 4->5->6->7
        t = cube[4];
        cube[4] = cube[5];
        cube[5] = cube[6];
        cube[6] = cube[7];
        cube[7] = t;

        // rotate edge positions 16->17->18->19 (bottom edges)
        t = cube[16];
        cube[16] = cube[17];
        cube[17] = cube[18];
        cube[18] = cube[19];
        cube[19] = t;
    }

    public void D2() {
    }

    public void R() {
        // rotate corner positions
        t = cube[1];
        cube[1] = cube[5];
        cube[5] = cube[6];
        cube[6] = cube[2];
        cube[2] = t;

        // rotate corners
        t = (byte) ((cube[21] + 2) % 3);
        cube[21] = (byte) ((cube[25] + 1) % 3);
        cube[25] = (byte) ((cube[26] + 2) % 3);
        cube[26] = (byte) ((cube[22] + 1) % 3);
        cube[22] = t;

        // rotate edge positions
        t = cube[1 + 8];
        cube[1 + 8] = cube[5 + 8];
        cube[5 + 8] = cube[9 + 8];
        cube[9 + 8] = cube[6 + 8];
        cube[6 + 8] = t;
    }

    public void Rp() {
        // inverse rotate corner positions 1<-5<-6<-2 (undo R)
        t = cube[2];
        cube[2] = cube[6];
        cube[6] = cube[5];
        cube[5] = cube[1];
        cube[1] = t;

        // inverse corner orientations for the right face (undo the orientation changes done in R)
        t = (byte) ((cube[21] + 2) % 3);
        cube[21] = (byte) ((cube[22] + 1) % 3);
        cube[22] = (byte) ((cube[26] + 2) % 3);
        cube[26] = (byte) ((cube[25] + 1) % 3);
        cube[25] = t;

        // inverse rotate edge positions (undo R)
        t = cube[14];
        cube[14] = cube[17];
        cube[17] = cube[13];
        cube[13] = cube[9];
        cube[9] = t;
    }

    public void R2() {
    }

    public void L() {
        byte[] cube = this.cube;
        byte t;

        // inverse rotate corner positions 0<-3<-7<-4 (undo L)
        t = cube[3];
        cube[3] = cube[7];
        cube[7] = cube[4];
        cube[4] = cube[0];
        cube[0] = t;

        // preserve original corner orientations then set according to inverse L mapping
        // t = (byte) ((cube[20 + 3] + 2) % 3);
        // cube[20 + 3] = (byte) ((cube[20 + 7] + 1) % 3);
        // cube[20 + 7] = (byte) ((cube[20 + 4] + 2) % 3);
        // cube[20 + 4] = (byte) ((cube[20 + 0] + 1) % 3);
        // cube[20 + 0] = t;

        // t = rotCorner2(cube[20 + 3]);
        // cube[20 + 3] = rotCorner1(cube[20 + 7]);
        // cube[20 + 7] = rotCorner2(cube[20 + 4]);
        // cube[20 + 4] = rotCorner1(cube[20 + 0]);
        // cube[20 + 0] = t;

        // inline corner-orientation update (avoid method calls and %)
        int o0 = cube[20 + 0] & 0xFF;
        int o3 = cube[20 + 3] & 0xFF;
        int o4 = cube[20 + 4] & 0xFF;
        int o7 = cube[20 + 7] & 0xFF;

        int t0 = o3 + 2; if (t0 >= 3) t0 -= 3;
        int n3 = o7 + 1; if (n3 >= 3) n3 -= 3;
        int n7 = o4 + 2; if (n7 >= 3) n7 -= 3;
        int n4 = o0 + 1; if (n4 >= 3) n4 -= 3;

        cube[20 + 3] = (byte) n3;
        cube[20 + 7] = (byte) n7;
        cube[20 + 4] = (byte) n4;
        cube[20 + 0] = (byte) t0;

        // inverse rotate edge positions 3<-4<-11<-7 (undo L)
        t = cube[8 + 7];
        cube[8 + 7] = cube[8 + 11];
        cube[8 + 11] = cube[8 + 4];
        cube[8 + 4] = cube[8 + 3];
        cube[8 + 3] = t;
    }

    private byte rotCorner1(byte c) {
        if (c == 0) return 1;
        else if (c == 1) return 2;
        else return 0;
    }

    private byte rotCorner2(byte c) {
        if (c == 0) return 2;
        else if (c == 1) return 0;
        else return 1;
    }

    public void Lp() {
        // rotate corner positions 0->3->7->4
        t = cube[0];
        cube[0] = cube[4];
        cube[4] = cube[7];
        cube[7] = cube[3];
        cube[3] = t;

        // rotate corner orientations (apply orientation deltas for the move)
        t = (byte) ((cube[20 + 0] + 1) % 3);
        cube[20 + 0] = (byte) ((cube[20 + 4] + 2) % 3);
        cube[20 + 4] = (byte) ((cube[20 + 7] + 1) % 3);
        cube[20 + 7] = (byte) ((cube[20 + 3] + 2) % 3);
        cube[20 + 3] = t;

        // rotate edge positions 3->7->11->4
        t = cube[8 + 3];
        cube[8 + 3] = cube[8 + 4];
        cube[8 + 4] = cube[8 + 11];
        cube[8 + 11] = cube[8 + 7];
        cube[8 + 7] = t;
    }

    public void L2() {
    }

    public void F() {
        // inverse rotate corner positions 2<-6<-7<-3 (undo F)
        t = cube[2];
        cube[2] = cube[6];
        cube[6] = cube[7];
        cube[7] = cube[3];
        cube[3] = t;

        // inverse rotate corner orientations for front face
        t = (byte) ((cube[20 + 2] + 2) % 3);
        cube[20 + 2] = (byte) ((cube[20 + 6] + 1) % 3);
        cube[20 + 6] = (byte) ((cube[20 + 7] + 2) % 3);
        cube[20 + 7] = (byte) ((cube[20 + 3] + 1) % 3);
        cube[20 + 3] = t;

        // inverse rotate edge positions 2<-6<-10<-7 (undo F)
        t = cube[8 + 2];
        cube[8 + 2] = cube[8 + 6];
        cube[8 + 6] = cube[8 + 10];
        cube[8 + 10] = cube[8 + 7];
        cube[8 + 7] = t;

        // inverse flip edge orientation
        t = cube[28 + 2];
        cube[28 + 2] = (byte) (cube[28 + 6] ^ 1);
        cube[28 + 6] = (byte) (cube[28 + 10] ^ 1);
        cube[28 + 10] = (byte) (cube[28 + 7] ^ 1);
        cube[28 + 7] = (byte) (t ^ 1);
    }

    public void Fp() {
        // rotate corner positions 2->3->7->6 (in-place cycle)
        t = cube[2];
        cube[2] = cube[3];
        cube[3] = cube[7];
        cube[7] = cube[6];
        cube[6] = t;

        // rotate corner orientations for front face
        t = (byte) ((cube[20 + 2] + 2) % 3); // old 2 -> new 6 (+1)
        cube[20 + 2] = (byte) ((cube[20 + 3] + 1) % 3); // old 3 -> new 2 (+2)
        cube[20 + 3] = (byte) ((cube[20 + 7] + 2) % 3); // old 7 -> new 3 (+1)
        cube[20 + 7] = (byte) ((cube[20 + 6] + 1) % 3); // old 6 -> new 7 (+2)
        cube[20 + 6] = t;

        // rotate edge positions 2->6->10->7 (in-place)
        t = cube[8 + 2];
        cube[8 + 2] = cube[8 + 7];
        cube[8 + 7] = cube[8 + 10];
        cube[8 + 10] = cube[8 + 6];
        cube[8 + 6] = t;

        // flip edge orientation
        t = cube[28 + 2];
        cube[28 + 2] = (byte) (cube[28 + 7] ^ 1);
        cube[28 + 7] = (byte) (cube[28 + 10] ^ 1);
        cube[28 + 10] = (byte) (cube[28 + 6] ^ 1);
        cube[28 + 6] = (byte) (t ^ 1);
    }

    public void F2() {
    }

    public void B() {
        // inverse rotate corner positions 0<-1<-5<-4 (undo B)
        t = cube[0];
        cube[0] = cube[1];
        cube[1] = cube[5];
        cube[5] = cube[4];
        cube[4] = t;

        // inverse rotate corner orientations for back face
        t = (byte) ((cube[20 + 0] + 1) % 3);
        cube[20 + 0] = (byte) ((cube[20 + 1] + 2) % 3);
        cube[20 + 1] = (byte) ((cube[20 + 5] + 1) % 3);
        cube[20 + 5] = (byte) ((cube[20 + 4] + 2) % 3);
        cube[20 + 4] = t;

        // inverse rotate edge positions 0<-5<-8<-4 (undo B)
        t = cube[8 + 0];
        cube[8 + 0] = cube[8 + 5];
        cube[8 + 5] = cube[8 + 8];
        cube[8 + 8] = cube[8 + 4];
        cube[8 + 4] = t;

        // inverse flip edge orientation
        t = cube[28 + 0];
        cube[28 + 0] = (byte) (cube[28 + 5] ^ 1);
        cube[28 + 5] = (byte) (cube[28 + 8] ^ 1);
        cube[28 + 8] = (byte) (cube[28 + 4] ^ 1);
        cube[28 + 4] = (byte) (t ^ 1);
    }

    public void Bp() {
        // rotate corner positions 0->1->5->4
        t = cube[4];
        cube[4] = cube[5];
        cube[5] = cube[1];
        cube[1] = cube[0];
        cube[0] = t;

        // rotate corner orientations for back face
        t = (byte) ((cube[20 + 4] + 1) % 3);
        cube[20 + 4] = (byte) ((cube[20 + 5] + 2) % 3);
        cube[20 + 5] = (byte) ((cube[20 + 1] + 2) % 3);
        cube[20 + 1] = (byte) ((cube[20 + 0] + 1) % 3);
        cube[20 + 0] = t;

        // rotate edge positions 0->4->8->5
        t = cube[8 + 0];
        cube[8 + 0] = cube[8 + 4];
        cube[8 + 4] = cube[8 + 8];
        cube[8 + 8] = cube[8 + 5];
        cube[8 + 5] = t;

        // flip edge orientation
        t = cube[28 + 0];
        cube[28 + 0] = (byte) (cube[28 + 4] ^ 1);
        cube[28 + 4] = (byte) (cube[28 + 8] ^ 1);
        cube[28 + 8] = (byte) (cube[28 + 5] ^ 1);
        cube[28 + 5] = (byte) (t ^ 1);
    }

    public void B2() {
    }
}